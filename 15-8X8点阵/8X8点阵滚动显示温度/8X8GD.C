/*--------------------------------------------------------------*/
//LED8*8滚动显示
//列扫描，低电平有效


/*--------------------------------------------------------------*/
//包含头文件
#include <reg52.h>
#include "74HC595.H"
#include<intrins.h>  //包含_nop_()函数定义的头文件

/*--------------------------------------------------------------*/
//全局变量定义
unsigned char  i,flag,t,w,t;
unsigned int  m,n;
unsigned char  t1,t2,t3,t4;

/*--------------------------------------------------------------*/
//代码库
#define  num  sizeof(buff)	//代码长度
unsigned char code aa[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};


unsigned char code table2[]={
0x60,0x60,0x00,0x3E,0x7F,0x41,0x7F,0x3E,/*"0",0*/
0x60,0x60,0x00,0x42,0x7F,0x7F,0x40,0x00,/*"1",1*/
0x60,0x60,0x00,0x62,0x73,0x59,0x4F,0x46,/*"2",2*/
0x60,0x60,0x00,0x22,0x6B,0x49,0x7F,0x36,/*"3",3*/
0x60,0x60,0x00,0x38,0x3E,0x7F,0x7F,0x20,/*"4",4*/
0x60,0x60,0x00,0x4F,0x4F,0x49,0x79,0x31,/*"5",5*/
0x60,0x60,0x00,0x3E,0x7F,0x49,0x7B,0x32,/*"6",6*/
0x60,0x60,0x00,0x03,0x73,0x79,0x0F,0x07,/*"7",7*/
0x60,0x60,0x00,0x36,0x7F,0x49,0x7F,0x36,/*"8",8*/
0x60,0x60,0x00,0x26,0x6F,0x49,0x7F,0x3E,/*"9",9*/
};

unsigned char code table1[]= {
//取模方式 阴码 列扫描 逆向

0x00,0x3E,0x7F,0x41,0x7F,0x3E,0x00,0x00,/*"0",0*/
0x00,0x42,0x7F,0x7F,0x40,0x00,0x00,0x00,/*"1",1*/
0x00,0x62,0x73,0x59,0x4F,0x46,0x00,0x00,/*"2",2*/
0x00,0x22,0x6B,0x49,0x7F,0x36,0x00,0x00,/*"3",3*/
0x00,0x38,0x3E,0x7F,0x7F,0x20,0x00,0x00,/*"4",4*/
0x00,0x4F,0x4F,0x49,0x79,0x31,0x00,0x00,/*"5",5*/
0x00,0x3E,0x7F,0x49,0x7B,0x32,0x00,0x00,/*"6",6*/
0x00,0x03,0x73,0x79,0x0F,0x07,0x00,0x00,/*"7",7*/
0x00,0x36,0x7F,0x49,0x7F,0x36,0x00,0x00,/*"8",8*/
0x00,0x26,0x6F,0x49,0x7F,0x3E,0x00,0x00,/*"9",9*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
};
unsigned char buff[]={

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
0x00,0x03,0x03,0x3E,0x7F,0x41,0x63,0x22,/*"C",0*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
};
/************************************************************************
以下是DS18B20的操作程序
 ************************************************************************/ 
sbit DQ=P3^3;
unsigned char time;   //设置全局变量，专门用于严格延时
/*****************************************************
函数功能：将DS18B20传感器初始化，读取应答信号
出口参数：flag 
***************************************************/
bit Init_DS18B20(void)	
{
 bit flag;         //储存DS18B20是否存在的标志，flag=0，表示存在；flag=1，表示不存在
 DQ = 1;           //先将数据线拉高
 for(time=0;time<2;time++) //略微延时约6微秒
     ;
 DQ = 0;           //再将数据线从高拉低，要求保持480~960us
 for(time=0;time<200;time++)  //略微延时约600微秒
     ;         //以向DS18B20发出一持续480~960us的低电平复位脉冲 
 DQ = 1;           //释放数据线（将数据线拉高） 
  for(time=0;time<10;time++)
     ;  //延时约30us（释放总线后需等待15~60us让DS18B20输出存在脉冲）
 flag=DQ;          //让单片机检测是否输出了存在脉冲（DQ=0表示存在）      
 for(time=0;time<200;time++)  //延时足够长时间，等待存在脉冲输出完毕
      ;
 return (flag);    //返回检测成功标志
}
/*****************************************************
函数功能：从DS18B20读取一个字节数据
出口参数：dat
***************************************************/ 
unsigned char ReadOneChar(void)
 {
		unsigned char i=0;	
		unsigned char dat;  //储存读出的一个字节数据
		for (i=0;i<8;i++)
		 {
		   
		   DQ =1;       // 先将数据线拉高
		   _nop_();	    //等待一个机器周期	 
		   DQ = 0;      //单片机从DS18B20读书据时,将数据线从高拉低即启动读时序
			dat>>=1;
		   _nop_();     //等待一个机器周期		   
		   DQ = 1;     //将数据线"人为"拉高,为单片机检测DS18B20的输出电平作准备
		   for(time=0;time<2;time++)
             ;      //延时约6us，使主机在15us内采样
		   if(DQ==1)
		      dat|=0x80;  //如果读到的数据是1，则将1存入dat
			else
				dat|=0x00;//如果读到的数据是0，则将0存入dat
		     //将单片机检测到的电平信号DQ存入r[i]	
		   for(time=0;time<8;time++)
		      	;              //延时3us,两个读时序之间必须有大于1us的恢复期	
	    }	                    
	 return(dat);    //返回读出的十进制数据
}
/*****************************************************
函数功能：向DS18B20写入一个字节数据
入口参数：dat
***************************************************/  
WriteOneChar(unsigned char dat)
{
	unsigned char i=0;
	for (i=0; i<8; i++)
		 {
		  DQ =1;         // 先将数据线拉高
		  _nop_();	     //等待一个机器周期	 
		  DQ=0;          //将数据线从高拉低时即启动写时序       
		  DQ=dat&0x01;   //利用与运算取出要写的某位二进制数据,
                       //并将其送到数据线上等待DS18B20采样	
		 for(time=0;time<10;time++)	
		     ;//延时约30us，DS18B20在拉低后的约15~60us期间从数据线上采样
		  DQ=1;          //释放数据线		    
		  for(time=0;time<1;time++)
			  ;//延时3us,两个写时序间至少需要1us的恢复期
		  dat>>=1;       //将dat中的各二进制位数据右移1位
		 }
	  for(time=0;time<4;time++)
	              ; //稍作延时,给硬件一点反应时间
}

void ReadyReadTemp(void)
{
      Init_DS18B20();     //将DS18B20初始化
		WriteOneChar(0xCC); // 跳过读序号列号的操作
		WriteOneChar(0x44); // 启动温度转换	  
	   for(time=0;time<100;time++)
	            ;	 //温度转换需要一点时间
		Init_DS18B20();     //将DS18B20初始化
		WriteOneChar(0xCC); //跳过读序号列号的操作
		WriteOneChar(0xBE); //读取温度寄存器,前两个分别是温度的低位和高位	
}

/*--------------------------------------------------------------*/
//显示函数
void Display(void)

{
 if(flag==2){
Ser_IN((aa[i])); //列扫描数据
 Ser_IN(buff[i + n]);				//查表取出行扫描数据
	Par_OUT();							//输出显示	
	i++; if(i == 8) i = 0;				//循环扫描
	m++; if(m == 100) {m = 0; n++;}		//滚动速度控制
	if(n == num-7)
	{
	 n = 0;				//循环显示
	 flag=1;
	}
  }

}

/*--------------------------------------------------------------*/
//定时器初始化
void T_init(void)
{
    TMOD = 0x11;
    TH0  = 0xfc; //1MS		
    TL0  = 0x66;
    EA = 1;					//允许CPU中断
	ET0 = 1; 				//定时器0中断打开
    TR0  = 1;
	
}


/*--------------------------------------------------------------*/
//定时器中断服务
void T0_intservice(void) interrupt 1 using 0
{
    TH0 = 0xfc;
    TL0 = 0x66;
 Display();	
}


/*--------------------------------------------------------------*/
//主函数
void main (void)
{
	 unsigned char TL;     //储存暂存器的温度低位
     unsigned char TH;    //储存暂存器的温度高位
     unsigned char TN;      //储存温度的整数部分
	  unsigned char TD;       //储存温度的小数部分    
	 
	  flag=1;

	T_init();
	while(1){
	  if(flag==1){
	ReadyReadTemp();     //读温度准备
	   TL=ReadOneChar();    //先读的是温度值低位
		TH=ReadOneChar();    //接着读的是温度值高位
		TN=TH*16+TL/16;      //实际温度值=(TH*256+TL)/16,即：TH*16+TL/16
			                  //这样得出的是温度的整数部分,小数部分被丢弃了
	   TD=(TL%16)*10/16;    //计算温度的小数部分,将余数乘以10再除以16取整，  	
	   t1=TN/100;              //取百位
	t2=(TN%100)/10;    //取十位
	t3=TN%10;             //取个位
	t4=TD;
	  flag=0;  
	}

 	if(flag==0){
	for(w=1;w<6;w++){
	if(w==5){
	
	flag=2;
	}
	for(t=0;t<8;t++){
	switch(w){
	case 1:
	buff[t+(8*w)]=table1[(8*t1)+t];
	break;
	 case 2:
	buff[t+(8*w)]=table1[(8*t2)+t];
	break;
	case 3:
	buff[t+(8*w)]=table1[(8*t3)+t];
	break;
	case 4:
	buff[t+(8*w)]=table2[(8*t4)+t];
	break;

	   }		          	
	     }
	       }
  	 }


	};		
		
}
