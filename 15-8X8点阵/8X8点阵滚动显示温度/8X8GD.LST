C51 COMPILER V8.18   8X8GD                                                                 01/04/2010 17:10:51 PAGE 1   


C51 COMPILER V8.18, COMPILATION OF MODULE 8X8GD
OBJECT MODULE PLACED IN 8X8GD.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 8X8GD.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*--------------------------------------------------------------*/
   2          //LED8*8滚动显示
   3          //列扫描，低电平有效
   4          
   5          
   6          /*--------------------------------------------------------------*/
   7          //包含头文件
   8          #include <reg52.h>
   9          #include "74HC595.H"
  10          #include<intrins.h>  //包含_nop_()函数定义的头文件
  11          
  12          /*--------------------------------------------------------------*/
  13          //全局变量定义
  14          unsigned char  i,flag,t,w,t;
  15          unsigned int  m,n;
  16          unsigned char  t1,t2,t3,t4;
  17          
  18          /*--------------------------------------------------------------*/
  19          //代码库
  20          #define  num  sizeof(buff)      //代码长度
  21          unsigned char code aa[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
  22          
  23          
  24          unsigned char code table2[]={
  25          0x60,0x60,0x00,0x3E,0x7F,0x41,0x7F,0x3E,/*"0",0*/
  26          0x60,0x60,0x00,0x42,0x7F,0x7F,0x40,0x00,/*"1",1*/
  27          0x60,0x60,0x00,0x62,0x73,0x59,0x4F,0x46,/*"2",2*/
  28          0x60,0x60,0x00,0x22,0x6B,0x49,0x7F,0x36,/*"3",3*/
  29          0x60,0x60,0x00,0x38,0x3E,0x7F,0x7F,0x20,/*"4",4*/
  30          0x60,0x60,0x00,0x4F,0x4F,0x49,0x79,0x31,/*"5",5*/
  31          0x60,0x60,0x00,0x3E,0x7F,0x49,0x7B,0x32,/*"6",6*/
  32          0x60,0x60,0x00,0x03,0x73,0x79,0x0F,0x07,/*"7",7*/
  33          0x60,0x60,0x00,0x36,0x7F,0x49,0x7F,0x36,/*"8",8*/
  34          0x60,0x60,0x00,0x26,0x6F,0x49,0x7F,0x3E,/*"9",9*/
  35          };
  36          
  37          unsigned char code table1[]= {
  38          //取模方式 阴码 列扫描 逆向
  39          
  40          0x00,0x3E,0x7F,0x41,0x7F,0x3E,0x00,0x00,/*"0",0*/
  41          0x00,0x42,0x7F,0x7F,0x40,0x00,0x00,0x00,/*"1",1*/
  42          0x00,0x62,0x73,0x59,0x4F,0x46,0x00,0x00,/*"2",2*/
  43          0x00,0x22,0x6B,0x49,0x7F,0x36,0x00,0x00,/*"3",3*/
  44          0x00,0x38,0x3E,0x7F,0x7F,0x20,0x00,0x00,/*"4",4*/
  45          0x00,0x4F,0x4F,0x49,0x79,0x31,0x00,0x00,/*"5",5*/
  46          0x00,0x3E,0x7F,0x49,0x7B,0x32,0x00,0x00,/*"6",6*/
  47          0x00,0x03,0x73,0x79,0x0F,0x07,0x00,0x00,/*"7",7*/
  48          0x00,0x36,0x7F,0x49,0x7F,0x36,0x00,0x00,/*"8",8*/
  49          0x00,0x26,0x6F,0x49,0x7F,0x3E,0x00,0x00,/*"9",9*/
  50          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
  51          };
  52          unsigned char buff[]={
  53          
  54          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
  55          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
C51 COMPILER V8.18   8X8GD                                                                 01/04/2010 17:10:51 PAGE 2   

  56          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
  57          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
  58          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
  59          0x00,0x03,0x03,0x3E,0x7F,0x41,0x63,0x22,/*"C",0*/
  60          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
  61          };
  62          /************************************************************************
  63          以下是DS18B20的操作程序
  64           ************************************************************************/ 
  65          sbit DQ=P3^3;
  66          unsigned char time;   //设置全局变量，专门用于严格延时
  67          /*****************************************************
  68          函数功能：将DS18B20传感器初始化，读取应答信号
  69          出口参数：flag 
  70          ***************************************************/
  71          bit Init_DS18B20(void)  
  72          {
  73   1       bit flag;         //储存DS18B20是否存在的标志，flag=0，表示存在；flag=1，表示不存在
  74   1       DQ = 1;           //先将数据线拉高
  75   1       for(time=0;time<2;time++) //略微延时约6微秒
  76   1           ;
  77   1       DQ = 0;           //再将数据线从高拉低，要求保持480~960us
  78   1       for(time=0;time<200;time++)  //略微延时约600微秒
  79   1           ;         //以向DS18B20发出一持续480~960us的低电平复位脉冲 
  80   1       DQ = 1;           //释放数据线（将数据线拉高） 
  81   1        for(time=0;time<10;time++)
  82   1           ;  //延时约30us（释放总线后需等待15~60us让DS18B20输出存在脉冲）
  83   1       flag=DQ;          //让单片机检测是否输出了存在脉冲（DQ=0表示存在）      
  84   1       for(time=0;time<200;time++)  //延时足够长时间，等待存在脉冲输出完毕
  85   1            ;
  86   1       return (flag);    //返回检测成功标志
  87   1      }
  88          /*****************************************************
  89          函数功能：从DS18B20读取一个字节数据
  90          出口参数：dat
  91          ***************************************************/ 
  92          unsigned char ReadOneChar(void)
  93           {
  94   1                      unsigned char i=0;      
  95   1                      unsigned char dat;  //储存读出的一个字节数据
  96   1                      for (i=0;i<8;i++)
  97   1                       {
  98   2                         
  99   2                         DQ =1;       // 先将数据线拉高
 100   2                         _nop_();         //等待一个机器周期   
 101   2                         DQ = 0;      //单片机从DS18B20读书据时,将数据线从高拉低即启动读时序
 102   2                              dat>>=1;
 103   2                         _nop_();     //等待一个机器周期                 
 104   2                         DQ = 1;     //将数据线"人为"拉高,为单片机检测DS18B20的输出电平作准备
 105   2                         for(time=0;time<2;time++)
 106   2                   ;      //延时约6us，使主机在15us内采样
 107   2                         if(DQ==1)
 108   2                            dat|=0x80;  //如果读到的数据是1，则将1存入dat
 109   2                              else
 110   2                                      dat|=0x00;//如果读到的数据是0，则将0存入dat
 111   2                           //将单片机检测到的电平信号DQ存入r[i]       
 112   2                         for(time=0;time<8;time++)
 113   2                              ;              //延时3us,两个读时序之间必须有大于1us的恢复期    
 114   2                  }                       
 115   1               return(dat);    //返回读出的十进制数据
 116   1      }
 117          /*****************************************************
C51 COMPILER V8.18   8X8GD                                                                 01/04/2010 17:10:51 PAGE 3   

 118          函数功能：向DS18B20写入一个字节数据
 119          入口参数：dat
 120          ***************************************************/  
 121          WriteOneChar(unsigned char dat)
 122          {
 123   1              unsigned char i=0;
 124   1              for (i=0; i<8; i++)
 125   1                       {
 126   2                        DQ =1;         // 先将数据线拉高
 127   2                        _nop_();           //等待一个机器周期  
 128   2                        DQ=0;          //将数据线从高拉低时即启动写时序       
 129   2                        DQ=dat&0x01;   //利用与运算取出要写的某位二进制数据,
 130   2                             //并将其送到数据线上等待DS18B20采样      
 131   2                       for(time=0;time<10;time++)     
 132   2                           ;//延时约30us，DS18B20在拉低后的约15~60us期间从数据线上采样
 133   2                        DQ=1;          //释放数据线               
 134   2                        for(time=0;time<1;time++)
 135   2                                ;//延时3us,两个写时序间至少需要1us的恢复期
 136   2                        dat>>=1;       //将dat中的各二进制位数据右移1位
 137   2                       }
 138   1                for(time=0;time<4;time++)
 139   1                            ; //稍作延时,给硬件一点反应时间
 140   1      }
 141          
 142          void ReadyReadTemp(void)
 143          {
 144   1            Init_DS18B20();     //将DS18B20初始化
 145   1                      WriteOneChar(0xCC); // 跳过读序号列号的操作
 146   1                      WriteOneChar(0x44); // 启动温度转换       
 147   1                 for(time=0;time<100;time++)
 148   1                          ;    //温度转换需要一点时间
 149   1                      Init_DS18B20();     //将DS18B20初始化
 150   1                      WriteOneChar(0xCC); //跳过读序号列号的操作
 151   1                      WriteOneChar(0xBE); //读取温度寄存器,前两个分别是温度的低位和高位       
 152   1      }
 153          
 154          /*--------------------------------------------------------------*/
 155          //显示函数
 156          void Display(void)
 157          
 158          {
 159   1       if(flag==2){
 160   2      Ser_IN((aa[i])); //列扫描数据
 161   2       Ser_IN(buff[i + n]);                           //查表取出行扫描数据
 162   2              Par_OUT();                                                      //输出显示      
 163   2              i++; if(i == 8) i = 0;                          //循环扫描
 164   2              m++; if(m == 100) {m = 0; n++;}         //滚动速度控制
 165   2              if(n == num-7)
 166   2              {
 167   3               n = 0;                         //循环显示
 168   3               flag=1;
 169   3              }
 170   2        }
 171   1      
 172   1      }
 173          
 174          /*--------------------------------------------------------------*/
 175          //定时器初始化
 176          void T_init(void)
 177          {
 178   1          TMOD = 0x11;
 179   1          TH0  = 0xfc; //1MS          
C51 COMPILER V8.18   8X8GD                                                                 01/04/2010 17:10:51 PAGE 4   

 180   1          TL0  = 0x66;
 181   1          EA = 1;                                     //允许CPU中断
 182   1              ET0 = 1;                                //定时器0中断打开
 183   1          TR0  = 1;
 184   1              
 185   1      }
 186          
 187          
 188          /*--------------------------------------------------------------*/
 189          //定时器中断服务
 190          void T0_intservice(void) interrupt 1 using 0
 191          {
 192   1          TH0 = 0xfc;
 193   1          TL0 = 0x66;
 194   1       Display();     
 195   1      }
 196          
 197          
 198          /*--------------------------------------------------------------*/
 199          //主函数
 200          void main (void)
 201          {
 202   1               unsigned char TL;     //储存暂存器的温度低位
 203   1           unsigned char TH;    //储存暂存器的温度高位
 204   1           unsigned char TN;      //储存温度的整数部分
 205   1                unsigned char TD;       //储存温度的小数部分    
 206   1               
 207   1                flag=1;
 208   1      
 209   1              T_init();
 210   1              while(1){
 211   2                if(flag==1){
 212   3              ReadyReadTemp();     //读温度准备
 213   3                 TL=ReadOneChar();    //先读的是温度值低位
 214   3                      TH=ReadOneChar();    //接着读的是温度值高位
 215   3                      TN=TH*16+TL/16;      //实际温度值=(TH*256+TL)/16,即：TH*16+TL/16
 216   3                                                //这样得出的是温度的整数部分,小数部分被丢弃了
 217   3                 TD=(TL%16)*10/16;    //计算温度的小数部分,将余数乘以10再除以16取整，         
 218   3                 t1=TN/100;              //取百位
 219   3              t2=(TN%100)/10;    //取十位
 220   3              t3=TN%10;             //取个位
 221   3              t4=TD;
 222   3                flag=0;  
 223   3              }
 224   2      
 225   2              if(flag==0){
 226   3              for(w=1;w<6;w++){
 227   4              if(w==5){
 228   5              
 229   5              flag=2;
 230   5              }
 231   4              for(t=0;t<8;t++){
 232   5              switch(w){
 233   6              case 1:
 234   6              buff[t+(8*w)]=table1[(8*t1)+t];
 235   6              break;
 236   6               case 2:
 237   6              buff[t+(8*w)]=table1[(8*t2)+t];
 238   6              break;
 239   6              case 3:
 240   6              buff[t+(8*w)]=table1[(8*t3)+t];
 241   6              break;
C51 COMPILER V8.18   8X8GD                                                                 01/04/2010 17:10:51 PAGE 5   

 242   6              case 4:
 243   6              buff[t+(8*w)]=table2[(8*t4)+t];
 244   6              break;
 245   6      
 246   6                 }                            
 247   5                   }
 248   4                     }
 249   3               }
 250   2      
 251   2      
 252   2              };              
 253   1                      
 254   1      }
*** WARNING C290 IN LINE 140 OF 8X8GD.C: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    566    ----
   CONSTANT SIZE    =    176    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     69    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
