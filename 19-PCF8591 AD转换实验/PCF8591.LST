C51 COMPILER V8.02   PCF8591                                                               12/31/2009 10:21:57 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE PCF8591
OBJECT MODULE PLACED IN PCF8591.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE PCF8591.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2          //-----------------------函数声明，变量定义------------------------
   3          #include <reg51.h>
   4          #include <intrins.h>
   5          sbit SCL=P1^2;                   // 将p1.2口模拟时钟口
   6          sbit SDA=P1^3;                   // 将p1.3口模拟数据口
   7          bit askflag;
   8          
   9          #define uchar unsigned char
  10          #define uint  unsigned int
  11          #define disdata  P0              //显示数据码输出口
  12          
  13          sbit LCD_RS = P2^0;             
  14          sbit LCD_RW = P2^1;
  15          sbit LCD_EN = P2^2;
  16          
  17          uint data dis[4]={0x00,0x00,0x00,0x00}; 
  18                                    //定义3个显示数据单元和1个数据存储单元
  19          
  20          uchar code dis4[] = {"1- .  V  2- .  V"};
  21          uchar code dis5[] = {"3- .  V  4- .  V"};
  22          
  23          
  24          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};
  25                                   
  26          bit   bdata SystemError;                //从机错误标志位
  27          
  28          /*********************** PCF8591专用变量定义 ***********************/
  29          
  30          #define PCF8591_WRITE   0x90
  31          #define PCF8591_READ    0x91
  32          #define  NUM  4                     //接收和发送缓存区的深度
  33          uchar idata receivebuf[NUM];    //数据接收缓冲区
  34          
  35          /*******************************************************************/
  36          /*                                                                 */
  37          /*  延时函数                                                       */
  38          /*                                                                 */
  39          /*******************************************************************/
  40          
  41          void delay(int ms)
  42          {
  43   1          while(ms--)
  44   1              {
  45   2            uchar i;
  46   2                for(i=0;i<250;i++)  
  47   2                 {
  48   3                  _nop_();                       
  49   3                      _nop_();
  50   3                      _nop_();
  51   3                      _nop_();
  52   3                 }
  53   2              }
  54   1      }               
  55          
C51 COMPILER V8.02   PCF8591                                                               12/31/2009 10:21:57 PAGE 2   

  56          /*******************************************************************/
  57          /*                                                                 */
  58          /*检查LCD忙状态                                                    */
  59          /*lcd_busy为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据。      */
  60          /*                                                                 */
  61          /*******************************************************************/ 
  62          
  63          bit lcd_busy()
  64           {                          
  65   1          bit result;
  66   1          LCD_RS = 0;
  67   1          LCD_RW = 1;
  68   1          LCD_EN = 1;
  69   1          delayNOP();
  70   1          result = (bit)(P0&0x80);
  71   1          LCD_EN = 0;
  72   1          return(result); 
  73   1       }
  74          
  75          /*******************************************************************/
  76          /*                                                                 */
  77          /*写指令数据到LCD                                                  */
  78          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  79          /*                                                                 */
  80          /*******************************************************************/
  81          
  82          void lcd_wcmd(uchar cmd)
  83          
  84          {                          
  85   1         while(lcd_busy());
  86   1          LCD_RS = 0;
  87   1          LCD_RW = 0;
  88   1          LCD_EN = 0;
  89   1          _nop_();
  90   1          _nop_(); 
  91   1          P0 = cmd;
  92   1          delayNOP();
  93   1          LCD_EN = 1;
  94   1          delayNOP();
  95   1          LCD_EN = 0;  
  96   1      }
  97          
  98          /*******************************************************************/
  99          /*                                                                 */
 100          /*写显示数据到LCD                                                  */
 101          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
 102          /*                                                                 */
 103          /*******************************************************************/
 104          
 105          void lcd_wdat(uchar dat)
 106          {                          
 107   1         while(lcd_busy());
 108   1          LCD_RS = 1;
 109   1          LCD_RW = 0;
 110   1          LCD_EN = 0;
 111   1          P0 = dat;
 112   1          delayNOP();
 113   1          LCD_EN = 1;
 114   1          delayNOP();
 115   1          LCD_EN = 0; 
 116   1      }
 117          
C51 COMPILER V8.02   PCF8591                                                               12/31/2009 10:21:57 PAGE 3   

 118          /*******************************************************************/
 119          /*                                                                 */
 120          /*  LCD初始化设定                                                  */
 121          /*                                                                 */
 122          /*******************************************************************/
 123          
 124          void lcd_init()
 125          { 
 126   1          delay(15);                   
 127   1          lcd_wcmd(0x38);      //16*2显示，5*7点阵，8位数据
 128   1          delay(5);
 129   1          lcd_wcmd(0x38);         
 130   1          delay(5);
 131   1          lcd_wcmd(0x38);         
 132   1          delay(5);
 133   1      
 134   1          lcd_wcmd(0x0c);      //显示开，关光标
 135   1          delay(5);
 136   1          lcd_wcmd(0x06);      //移动光标
 137   1          delay(5);
 138   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 139   1          delay(5);
 140   1      }
 141          
 142          /*******************************************************************/
 143          /*                                                                 */
 144          /*  设定显示位置                                                   */
 145          /*                                                                 */
 146          /*******************************************************************/
 147          
 148          void lcd_pos(uchar pos)
 149          {                          
 150   1        lcd_wcmd(pos | 0x80);  //数据指针=80+地址变量
 151   1      }
 152          
 153          /******************************************************************/
 154          /*                                                                */
 155          /* 数据处理与显示                                                 */
 156          /* 将采集到的数据进行16进制转换为ASCLL码。                        */
 157          /*                                                                */
 158          /******************************************************************/
 159          
 160          show_value(uchar ad_data)
 161          
 162          {   
 163   1          dis[2]=ad_data/51;   //AD值转换为3为BCD码，最大为5.00V。
 164   1          dis[2]=dis[2]+0x30;  //转换为ACSII码
 165   1          dis[3]=ad_data%51;   //余数暂存
 166   1          dis[3]=dis[3]*10;    //计算小数第一位
 167   1          dis[1]=dis[3]/51;
 168   1          dis[1]=dis[1]+0x30;  //转换为ACSII码
 169   1          dis[3]=dis[3]%51;
 170   1          dis[3]=dis[3]*10;    //计算小数第二位
 171   1          dis[0]=dis[3]/51;                                                                             //
 172   1          dis[0]=dis[0]+0x30;  //转换为ACSII码           
 173   1      } 
 174          //-------------------------------------------------------------------
 175          // 函数名称： iic_start()
 176          // 函数功能： 启动I2C总线子程序
 177          //-------------------------------------------------------------------
 178          void iic_start(void)
 179          { //时钟保持高，数据线从高到低一次跳变，I2C通信开始
C51 COMPILER V8.02   PCF8591                                                               12/31/2009 10:21:57 PAGE 4   

 180   1              SDA = 1;     
 181   1              SCL = 1;
 182   1              delayNOP();      // 延时5us 
 183   1              SDA = 0;
 184   1              delayNOP();
 185   1          SCL = 0;
 186   1      }
 187          //-------------------------------------------------------------------
 188          // 函数名称： iic_stop()
 189          // 函数功能： 停止I2C总线数据传送子程序
 190          //-------------------------------------------------------------------
 191          void iic_stop(void)
 192          {       
 193   1              SDA = 0;           //时钟保持高，数据线从低到高一次跳变，I2C通信停止
 194   1              SCL = 1;
 195   1              delayNOP();
 196   1              SDA = 1;
 197   1              delayNOP();
 198   1          SCL = 0;
 199   1      }
 200          //------------------------------------------------------------------
 201          // 函数名称： iicInit_()
 202          // 函数功能： 初始化I2C总线子程序
 203          //------------------------------------------------------------------
 204           void iicInit(void)
 205             {
 206   1         SCL = 0;
 207   1         iic_stop();  
 208   1         }  
 209          //-------------------------------------------------------------------
 210          // 函数名称： slave_ACK
 211          // 函数功能： 从机发送应答位子程序
 212          //-------------------------------------------------------------------
 213          void slave_ACK(void)
 214          {
 215   1              SDA = 0;  
 216   1              SCL = 1;
 217   1              delayNOP();     
 218   1              SCL = 0;
 219   1      }
 220          //-------------------------------------------------------------------
 221          // 函数名称： slave_NOACK
 222          // 函数功能： 从机发送非应答位子程序，迫使数据传输过程结束
 223          //-------------------------------------------------------------------
 224          void slave_NOACK(void)
 225          { 
 226   1              SDA = 1;
 227   1              SCL = 1;
 228   1              delayNOP();
 229   1              SDA = 0;
 230   1          SCL = 0;  
 231   1      }
 232          //-------------------------------------------------------------------
 233          // 函数名称： check_ACK
 234          // 函数功能： 主机应答位检查子程序，迫使数据传输过程结束
 235          //-------------------------------------------------------------------
 236          void check_ACK(void)
 237          {           
 238   1          SDA = 1;        // 将p1.1设置成输入，必须先向端口写1
 239   1              SCL = 1;
 240   1              askflag = 0;
 241   1              delayNOP();   
C51 COMPILER V8.02   PCF8591                                                               12/31/2009 10:21:57 PAGE 5   

 242   1              if(SDA == 1)    // 若SDA=1表明非应答，置位非应答标志askflag
 243   1          askflag = 1;
 244   1              SCL = 0;
 245   1      }
 246          //-------------------------------------------------------------------
 247          // 函数名称： IICSendByte
 248          // 入口参数： ch
 249          // 函数功能： 发送一个字节
 250          //-------------------------------------------------------------------
 251          void IICSendByte(uchar ch)
 252           
 253          {
 254   1              unsigned char idata n=8;     // 向SDA上发送一位数据字节，共八位
 255   1      
 256   1              while(n--)
 257   1              { 
 258   2              if((ch&0x80) == 0x80)    // 若要发送的数据最高位为1则发送位1
 259   2                 {
 260   3                              SDA = 1;    // 传送位1
 261   3                              SCL = 1;
 262   3                          delayNOP();
 263   3                      //      SDA = 0;        
 264   3                              SCL = 0; 
 265   3                 }
 266   2                      else
 267   2                      {  
 268   3                              SDA = 0;    // 否则传送位0
 269   3                              SCL = 1;
 270   3                              delayNOP();
 271   3                              SCL = 0;
 272   3                      }
 273   2                      ch = ch<<1;    // 数据左移一位
 274   2              }
 275   1      }
 276          //-------------------------------------------------------------------
 277          // 函数名称： IICreceiveByte
 278          // 返回接收的数据
 279          // 函数功能： 接收一字节子程序
 280          //-------------------------------------------------------------------
 281          uchar IICreceiveByte(void)
 282          {
 283   1              uchar idata n=8;     // 从SDA线上读取一上数据字节，共八位
 284   1              uchar tdata=0;
 285   1              while(n--)
 286   1              {
 287   2                 SDA = 1;
 288   2                 SCL = 1;
 289   2                 tdata =tdata<<1;                 //左移一位
 290   2                      if(SDA == 1)
 291   2                        tdata = tdata|0x01;   // 若接收到的位为1，则数据的最后一位置1
 292   2                      else 
 293   2                        tdata = tdata&0xfe;   // 否则数据的最后一位置0
 294   2                 SCL = 0;
 295   2               }
 296   1      
 297   1               return(tdata);
 298   1      }
 299          //-------------------------------------------------------------------
 300          // 函数名称： DAC_PCF8591
 301          // 入口参数： slave_add从机地址,n要发送的数据个数
 302          // 函数功能： 发送n位数据子程序
 303          //-------------------------------------------------------------------
C51 COMPILER V8.02   PCF8591                                                               12/31/2009 10:21:57 PAGE 6   

 304          void DAC_PCF8591(uchar controlbyte,uchar w_data)
 305          {    
 306   1              
 307   1              iic_start();                    // 启动I2C
 308   1              delayNOP();
 309   1      
 310   1              IICSendByte(PCF8591_WRITE);     // 发送地址位
 311   1              check_ACK();                    // 检查应答位
 312   1          if(askflag == 1)
 313   1               { 
 314   2                      SystemError = 1;
 315   2                      return;                     // 若非应答，置错误标志位
 316   2           }
 317   1          IICSendByte(controlbyte&0x77);      //Control byte 
 318   1              check_ACK();                    //检查应答位
 319   1          if(askflag == 1)
 320   1               { 
 321   2                      SystemError = 1;
 322   2                      return;                    // 若非应答，置错误标志位
 323   2               }
 324   1          IICSendByte(w_data);               //data byte
 325   1              check_ACK();                  // 检查应答位
 326   1          if(askflag == 1)
 327   1               { 
 328   2                      SystemError = 1;
 329   2              return;   // 若非应答表明器件错误或已坏，置错误标志位SystemError
 330   2               }
 331   1              iic_stop();         // 全部发完则停止
 332   1              delayNOP();
 333   1              delayNOP();
 334   1              delayNOP();
 335   1              delayNOP();     
 336   1      }
 337          //-------------------------------------------------------------------
 338          // 函数名称： ADC_PCF8591
 339          // 入口参数： controlbyte控制字
 340          // 函数功能： 连续读入4路通道的A/D转换结果到receivebuf
 341          //-------------------------------------------------------------------
 342          void ADC_PCF8591(uchar controlbyte)
 343          { 
 344   1          uchar idata receive_da,i=0;
 345   1      
 346   1              iic_start();
 347   1      
 348   1              IICSendByte(PCF8591_WRITE);     //控制字
 349   1              check_ACK();
 350   1              if(askflag == 1)
 351   1              {
 352   2                      SystemError = 1;
 353   2                      return;
 354   2              }
 355   1      
 356   1              IICSendByte(controlbyte);       //控制字
 357   1              check_ACK();
 358   1              if(askflag == 1)
 359   1              {
 360   2                      SystemError = 1;
 361   2                      return;
 362   2              }
 363   1      
 364   1          iic_start();                //重新发送开始命令
 365   1              IICSendByte(PCF8591_READ);      //控制字
C51 COMPILER V8.02   PCF8591                                                               12/31/2009 10:21:57 PAGE 7   

 366   1              check_ACK();
 367   1              if(askflag == 1)
 368   1              {
 369   2                      SystemError = 1;
 370   2                      return;
 371   2              }
 372   1               
 373   1          IICreceiveByte();   //空读一次，调整读顺序
 374   1          slave_ACK();        //收到一个字节后发送一个应答位
 375   1      
 376   1              while(i<4)
 377   1              {  
 378   2                receive_da=IICreceiveByte();
 379   2                receivebuf[i++]=receive_da;
 380   2                slave_ACK();       //收到一个字节后发送一个应答位
 381   2              }
 382   1              slave_NOACK();       //收到最后一个字节后发送一个非应答位
 383   1              iic_stop();
 384   1      }
 385          //-------------------------------------------------------------------
 386          // 函数名称： main
 387          // 函数功能： 主程序
 388          //-------------------------------------------------------------------
 389          main()
 390          {
 391   1          uchar i,l;
 392   1          delay(10);                 //延时
 393   1          lcd_init();                //初始化LCD             
 394   1              
 395   1          lcd_pos(0);                //设置显示位置为第一行的第1个字符
 396   1           i = 0;
 397   1          while(dis4[i] != '\0')
 398   1           {                         //显示字符
 399   2             lcd_wdat(dis4[i]);
 400   2             i++;
 401   2           }
 402   1      
 403   1          lcd_pos(0x40);             //设置显示位置为第二行第1个字符
 404   1           i = 0;
 405   1          while(dis5[i] != '\0')
 406   1           {
 407   2             lcd_wdat(dis5[i]);      //显示字符
 408   2             i++;
 409   2           }
 410   1              
 411   1        while(1)
 412   1        {
 413   2              iicInit();                    //I2C总线初始化
 414   2          ADC_PCF8591(0x04);
 415   2      
 416   2              if(SystemError == 1)      //有错误，重新来
 417   2                {
 418   3                      iicInit();                                //I2C总线初始化
 419   3                  ADC_PCF8591(0x04);
 420   3                 }   
 421   2              
 422   2              for(l=0;l<4;l++)        
 423   2               {
 424   3                show_value(receivebuf[0]); //显示通道0       
 425   3                  lcd_pos(0x02);             
 426   3              lcd_wdat(dis[2]);        //整数位显示
 427   3              lcd_pos(0x04);             
C51 COMPILER V8.02   PCF8591                                                               12/31/2009 10:21:57 PAGE 8   

 428   3              lcd_wdat(dis[1]);        //第一位小数显示 
 429   3              lcd_pos(0x05);             
 430   3              lcd_wdat(dis[0]);        //第二位小数显示
 431   3      
 432   3            show_value(receivebuf[1]); //显示通道1     
 433   3                  lcd_pos(0x0b);             
 434   3              lcd_wdat(dis[2]);        //整数位显示
 435   3              lcd_pos(0x0d);             
 436   3              lcd_wdat(dis[1]);        //第一位小数显示 
 437   3              lcd_pos(0x0e);             
 438   3              lcd_wdat(dis[0]);        //第二位小数显示
 439   3      
 440   3                show_value(receivebuf[2]); //显示通道2                 
 441   3                  lcd_pos(0x42);             
 442   3              lcd_wdat(dis[2]);        //整数位显示
 443   3              lcd_pos(0x44);             
 444   3              lcd_wdat(dis[1]);        //第一位小数显示 
 445   3              lcd_pos(0x45);             
 446   3              lcd_wdat(dis[0]);        //第二位小数显示
 447   3      
 448   3            show_value(receivebuf[3]); //显示通道3     
 449   3                  lcd_pos(0x4b);             
 450   3              lcd_wdat(dis[2]);        //整数位显示
 451   3              lcd_pos(0x4d);              
 452   3              lcd_wdat(dis[1]);        //第一位小数显示 
 453   3              lcd_pos(0x4e);             
 454   3              lcd_wdat(dis[0]);        //第二位小数显示
 455   3      
 456   3                iicInit();                  //I2C总线初始化  
 457   3            DAC_PCF8591(0x40,receivebuf[0]); //D/A输出
 458   3      
 459   3                      if(SystemError == 1)      //有错误，重新来
 460   3                  {
 461   4                       iicInit();                               //I2C总线初始化
 462   4                       DAC_PCF8591(0x40,receivebuf[0]); //D/A输出
 463   4                  }           
 464   3      
 465   3            //delay(50);                       //延时
 466   3               }
 467   2      
 468   2         }
 469   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    861    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       1
   IDATA SIZE       =      4       4
   BIT SIZE         =      2       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
